; args: 2d_array (map), neighbors, visited_crossings, last_wave_neighs, 1 local vars
; return: dir

!def ld_map                 LD 0 0
!def ld_neighbors           LD 0 1
!def ld_cross_visited       LD 0 2
!def st_cross_visited       ST 0 2
!def ld_last_visited        LD 0 3
!def st_last_visited        ST 0 3
!def ld_loc_tasty           LD 0 4
!def st_loc_tasty           ST 0 4

LDC -42
DBUG
#ld_neighbors
DBUG
LDC -56
DBUG
#ld_cross_visited
DBUG

#ld_neighbors
LDF @neighbor_accum_valuable
LDC 0
LDF @reduce
AP 3

#st_loc_tasty
#ld_loc_tasty

ATOM ; test for empty valuable neighs
TSEL $empty $some
$empty:
    #ld_map ; used for the recursive call of map_walk

    ; filter walkable neighs
    #ld_neighbors
    LDF @neighbor_accum_walkable
    LDC 0
    LDF @reduce
    AP 3     ; get neighbors of walkable neighbors
    #call_copy
    #st_last_visited

    LDF @neighbor_accum_neighbors ; load new neighbors&crossings
    LDC 0
    LDC 0
    CONS
    LDF @reduce
    AP 3

    #call_copy
    CAR
    LDF @neighbor_accum_not_visited ; remove last visited wave
    LDC 0
    LDF @reduce
    AP 3

    #call_flip
    ; neighb&cr + filtered + map
    CDR

    ; cr + filtered  + map
    LDF @concat_accum
    #ld_cross_visited
    LDF @reduce ; new, func, old
    AP 3
    ; new_cross + filtered  + map
    #st_cross_visited
    ; filtered + map

    LDF @neighbor_accum_not_crossings ; remove visited crossings
    LDC 0
    LDF @reduce
    AP 3

    #ld_cross_visited
    #ld_last_visited
    LDC 0 ; just for local var

    LDF @map_walk
    AP 5

    RTN
$some:
    #ld_loc_tasty
    CAR
    CDR
    CDR
    RTN
